#ifndef MOTION
#define MOTION

#include "parameter.h"
#include "objects.h"
#include "audio.h"


int prev_x = 0, prev_y = 0;
bool escape_pressed = false;
bool reposition = false;

void processSpecialKeys(int key, int xx, int yy)
{
	float fraction = 0.001f;
	float fraction_rotate = 0.001f;
	static int lastStepMs = 0;
	
	if (!motion_present)
		return;

	auto maybeStep = [&]() {
		// Avoid spamming on key repeat.
		int now = glutGet(GLUT_ELAPSED_TIME);
		if (now - lastStepMs < 180)
			return;
		lastStepMs = now;
		audio::play_step("data/sfx/step.wav", 0.35f);
	};

	switch (key) {
	case GLUT_KEY_LEFT:
		x -= cos(angle) * deltaTime * fraction;
		z -= sin(angle) * deltaTime * fraction;
		maybeStep();
		break;
	case GLUT_KEY_RIGHT:
		x += cos(angle) * deltaTime * fraction;
		z += sin(angle) * deltaTime * fraction;
		maybeStep();

		break;
	case GLUT_KEY_UP:

		x += lx * deltaTime * fraction;
		z += lz * deltaTime * fraction;
		maybeStep();

		break;
	case GLUT_KEY_DOWN:
		x -= lx * deltaTime * fraction;
		z -= lz * deltaTime * fraction;
		maybeStep();

		break;
	case GLUT_KEY_HOME:
		angle -= deltaTime * fraction_rotate;
		lx = sin(angle);
		lz = -cos(angle);
		audio::play_ui("data/sfx/ui_click.wav", 0.25f);
		break;
	case GLUT_KEY_END:
		angle += deltaTime * fraction_rotate;
		lx = sin(angle);
		lz = -cos(angle);
		audio::play_ui("data/sfx/ui_click.wav", 0.25f);
		break;
	case GLUT_KEY_PAGE_UP:
		y < 1.4f ? y += deltaTime * fraction_rotate * 0.5 : y = 1.4f;
		break;
	case GLUT_KEY_PAGE_DOWN:
		y > -0.8f ? y -= deltaTime * fraction_rotate * 0.5 : y = -0.8f;
		break;
	}
}

void processNormalKeys(unsigned char key, int x, int y)
{
	static int lastActionMs = 0;
	auto allowAction = [&]() {
		int now = glutGet(GLUT_ELAPSED_TIME);
		if (now - lastActionMs < 180)
			return false;
		lastActionMs = now;
		return true;
	};

	switch (key) {
	case 13:if (page == 0) 
				motion_present = true;
			if (page == 1) {
				enterPressed = true;
				assemble = false;
				objIndex > REMOVE_MOTHERBOARD? objIndex:objIndex++;
				if (allowAction())
					audio::play3d("data/sfx/disassemble.wav", {2.0f, 1.0f, -2.0f}, 0.9f, audio::Channel::ACTION);
			}
			else {
				audio::play_ui("data/sfx/enter.wav", 0.7f);
			}
			page = 1;			 
			 break;
	case 8:if (page == 1) {
			enterPressed = true;
			assemble = true;
			objIndex < -1 ? objIndex : objIndex--;
			if (allowAction())
				audio::play3d("data/sfx/assemble.wav", {2.0f, 1.0f, -2.0f}, 0.9f, audio::Channel::ACTION);
		   }
		   break;
	case 'y':
	case 'Y':choice = 'y'; break;

	case 'n':
	case 'N':choice = 'n'; break;
	case 27:escape_pressed = true;
			audio::play_ui("data/sfx/ui_click.wav", 0.5f);
			if (!motion_present && choice == 'y') {
				// Exiting disassembly view.
				audio::stop(audio::Channel::ACTION);
				motion_present = true;
			}
			else
				exit(0);
	}
}

// Global mouse tracking for TooltipSystem
extern int mouseGlobalX;
extern int mouseGlobalY;

void mouse_follow(int new_x, int new_y) {
    // Always track mouse position for tooltips
    mouseGlobalX = new_x;
    mouseGlobalY = new_y;

	if (motion_present == false)
		return;

    int centerX = width / 2;
    int centerY = hight / 2;

    // Ignore the event generated by glutWarpPointer
    if (new_x == centerX && new_y == centerY) return;

    int dx = new_x - centerX;
    int dy = new_y - centerY;

    float sensitivity = 0.001f;

    angle += dx * sensitivity;
    lx = sin(angle);
    lz = -cos(angle);

    // Invert Y axis for look up/down usually feels more natural in FPS, 
    // but code previously used opposite logic. Let's stick to standard behavior.
    // Previous: y - delta ...
    // If mouse goes DOWN (dy > 0), y should DECREASE (look down)? 
    // Wait, 'y' is camera HEIGHT in this engine?
    // "y < 1.4f ? y += deltaTime..." in processSpecialKeys implies y is height.
    // Yes, gluLookAt(x, 5.0f, z, x + lx, y, z + lz, ...)
    // Wait, the LookAt center is (x+lx, y, z+lz). So 'y' is the Y-coordinate of the Target point.
    // So if I move mouse down (dy > 0), I want to look down, so 'y' should decrease.
    
    float lookSensitivity = 0.01f;
    y -= dy * lookSensitivity;

    if (y > UPPER_Y) y = UPPER_Y;
    if (y < LOWER_Y) y = LOWER_Y;

    // Re-center mouse
    glutWarpPointer(centerX, centerY);
    
    prev_x = centerX;
    prev_y = centerY;
}

void printMsg(char * message,GLfloat mX, GLfloat mY, GLfloat mZ) {
	glRasterPos3f(mX, mY, mZ);
	for (char* c = message; *c != '\0'; c++) {
		glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, *c);
	}
}

void cpuView() {

	// For CPU View
	GLfloat baseX = 2., baseY = 1., baseZ = -2.;
	//GLfloat baseWidth = 8.;
	//glColor3f(1., 0., 0.);
	//glBegin(GL_POLYGON);
	//glVertex3f(baseX, baseY, baseZ);
	//glVertex3f(baseX + baseWidth, baseY, baseZ);
	//glVertex3f(baseX + baseWidth, baseY, baseZ - baseWidth);
	//glVertex3f(baseX, baseY, baseZ - baseWidth);
	//glEnd();


	if (x >= baseX && z <= baseZ){	// Inside ?
		glColor3f(1., 1., 1.);
		if (choice == '1') {
			printMsg((char*)"Do you want to Disassemble ? Enter Y / N", 3., 5., -6.);
			reposition = true;
		}
		else if (choice == 'n')
		{	/// Set camera position
			enterPressed = false;
		}
		else if (choice == 'y') {
	
			if (!escape_pressed) {
				printMsg((char*)"Press Enter to disassemble / Backspace to assemble", 5.24, 4.1, -4.275);
				printMsg((char*)"Esc to exit view", 5.24, 3.8, -5.35);
			}
			if (reposition == true) {
				x = disXYZ[0];	lx = disLxLyLz[0];	
				z = disXYZ[2];	lz = disLxLyLz[2];
				reposition = false;
				motion_present = false;
			}
		}
	}
	else {
		choice = '1';
		enterPressed = false;
		escape_pressed = false;
		audio::stop(audio::Channel::ACTION);
	}
}
#endif MOTION